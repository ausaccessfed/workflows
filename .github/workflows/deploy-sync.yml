name: Build Docker Image
on:
  workflow_call:
    inputs:
      ecr_repository:
        required: true
        type: string
      dev_url:
        default: ''
        type: string
      event_name:
        required: true
        type: string
      event_comment_body:
        default: ''
        type: string
      event_comment_id:
        default: ''
        type: string
      default_branch:
        default: 'master'
        type: string
      ## if not set defaults to default_branch
      default_branch_for_caching:
        default: ''
        type: string
      ## if not set defaults to default_branch
      default_develop_branch:
        default: ''
        type: string
      version_command:
        default: 'cat .ruby-version'
        type: string
      ## used to allow for custom "latest" tags i.e ruby-base so we can tag with 3.2.2 or 3.3
      latest_image_tag:
        default: 'latest'
        type: string
      ## If set to '' then service will not be started
      mysql_image_tag_version:
        default: '8'
        type: string
      ## if not set defaults to ecr_repository
      projects:
        default: ''
        type: string
      platforms:
        default: "['linux/amd64']"
        type: string
      runner:
        default: 'ubuntu-latest'
        type: string
      development_environments:
        default: 'development'
        type: string
      test_environments:
        default: ''
        type: string
      production_environments:
        default: 'test,production'
        type: string
      save_test_artifacts:
        default: false
        type: boolean
      commands:
        default: '[]'
        type: string
    secrets:
      ROLE:
        required: true
      SNYK_TOKEN:
        required: true
jobs:
  init:
    outputs:
      HEAD_SHA: ${{ steps.comment-branch.outputs.HEAD_SHA }}
      IS_SLASH_DEPLOY: ${{ steps.env.outputs.IS_SLASH_DEPLOY }}
      PUBLISH_APP_IMAGE_ID_TAG: ${{ steps.env.outputs.PUBLISH_APP_IMAGE_ID_TAG }}
      IMAGE_TAG: ${{ steps.env.outputs.IMAGE_TAG }}
      PROJECTS: ${{ steps.env.outputs.PROJECTS }}
      IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH: ${{ steps.env.outputs.IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH }}
      IS_MONTHLY_BUILD: ${{ steps.env.outputs.IS_MONTHLY_BUILD }}
      IS_DEFAULT_BRANCH_PUSH: ${{ steps.env.outputs.IS_DEFAULT_BRANCH_PUSH }}
      BRANCH_NAME: ${{ steps.branch.outputs.BRANCH_NAME }}
      RUBY_VERSION: ${{ steps.env.outputs.RUBY_VERSION }}
      BASE_IMAGE: ${{ steps.env.outputs.BASE_IMAGE }}
      PRODUCTION_IMAGE_ID_TAG: ${{ steps.env.outputs.PRODUCTION_IMAGE_ID_TAG }}
      LATEST_IMAGE_ID_TAG: ${{ steps.env.outputs.LATEST_IMAGE_ID_TAG }}
      SHOULD_PUSH_IMAGE_TO_ECR: ${{ steps.env.outputs.SHOULD_PUSH_IMAGE_TO_ECR }}
      IMAGE_SCANNER_COMMON: ${{ steps.env.outputs.IMAGE_SCANNER_COMMON }}
      GITHUB_REGISTRY_REF: ${{ steps.env.outputs.GITHUB_REGISTRY_REF }}
      GITHUB_CACHE_IMAGE_ID_TAG: ${{ steps.env.outputs.GITHUB_CACHE_IMAGE_ID_TAG }}
      GITHUB_LATEST_IMAGE_ID_TAG: ${{ steps.env.outputs.GITHUB_LATEST_IMAGE_ID_TAG }}
      GITHUB_BRANCH_CACHE_IMAGE_ID_TAG: ${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
      GITHUB_BRANCH_LATEST_IMAGE_ID_TAG: ${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
    name: init
    runs-on: ubuntu-latest
    if: inputs.event_name != 'issue_comment' || (contains(inputs.event_comment_body, '/deploy')  && contains(fromJSON(vars.ALLOWED_ACTORS), github.event.comment.user.login))
    steps:
      - uses: xt0rted/pull-request-comment-branch@d97294d304604fa98a2600a6e2f916a84b596dc7 # v2.0.0
        if: inputs.event_name == 'issue_comment'
        id: comment-branch

      - name: Set commit status as pending
        uses: myrotvorets/set-commit-status-action@3730c0a348a2ace3c110851bed53331bc6406e9f # v2.0.1
        if: inputs.event_name == 'issue_comment'
        with:
          sha: ${{ steps.comment-branch.outputs.HEAD_SHA }}
          token: ${{ secrets.GITHUB_TOKEN }}
          status: pending
          description: 'testing, building and pushing image'
          context: 'Dev federation deploy'

      - id: branch
        name: set envs
        run: |
          ## PR comment branch || pr branch || default branch
          if [ "${{ steps.comment-branch.outputs.head_ref }}" != "" ]; then
            BRANCH_NAME="${{ steps.comment-branch.outputs.head_ref }}"
          elif [ "${{ github.head_ref }}" != "" ]; then
            BRANCH_NAME="${{ github.head_ref }}"
          else
            BRANCH_NAME="${{ github.ref_name }}"
          fi
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/init@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ steps.branch.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}

      - name: set more envs
        id: env
        run: |
          IS_SLASH_DEPLOY=$([ "${{ inputs.event_name }}" == "issue_comment" ] && echo "true" || echo "false")
          echo "IS_SLASH_DEPLOY=$IS_SLASH_DEPLOY" >> $GITHUB_OUTPUT

          IS_MONTHLY_BUILD=$([ "${{ inputs.event_name }}" == "schedule" ] && echo "true" || echo "false")
          echo "IS_MONTHLY_BUILD=$IS_MONTHLY_BUILD" >> $GITHUB_OUTPUT

          IS_DEFAULT_BRANCH_PUSH=$(([ "${{ inputs.event_name }}" == "push" ] && [ "${{steps.branch.outputs.BRANCH_NAME}}" == "${{ inputs.default_branch }}" ]) && echo "true" || echo "false")
          echo "IS_DEFAULT_BRANCH_PUSH=$IS_DEFAULT_BRANCH_PUSH" >> $GITHUB_OUTPUT

          IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH=$(([ "${{ inputs.event_name }}" == "push" ] && [ "${{steps.branch.outputs.BRANCH_NAME}}" == "${{ inputs.default_develop_branch }}" ]) && echo "true" || echo "false")
          echo "IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH=$IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH" >> $GITHUB_OUTPUT

          DEFAULT_BRANCH_FOR_CACHING=$([ "${{ inputs.default_branch_for_caching }}" == "" ] && echo "${{ inputs.default_branch }}" || echo "${{ inputs.default_branch_for_caching }}")

          if [ "$IS_SLASH_DEPLOY" == "true" ]; then
            IMAGE_TAG=adhoc-${{steps.comment-branch.outputs.head_ref}}-${{steps.comment-branch.outputs.HEAD_SHA}}
          else
            IMAGE_TAG=stable-${{ github.sha }}
          fi
          IMAGE_TAG=$(echo "$IMAGE_TAG" | tr / _)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT

          SHOULD_PUSH_IMAGE_TO_ECR=$([ \
            "$IS_DEFAULT_BRANCH_PUSH" == "true" \
            -o \
            "$IS_SLASH_DEPLOY" == "true" \
            -o \
            "$IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH" == "true" \
            -o \
            "$IS_MONTHLY_BUILD" == "true" \
          ] && echo "true" || echo "false")
          echo "SHOULD_PUSH_IMAGE_TO_ECR=$SHOULD_PUSH_IMAGE_TO_ECR" >> $GITHUB_OUTPUT

          DOCKER_ECR=$(aws secretsmanager get-secret-value --secret-id "aaf-terraform-DOCKER_ECR" --query 'SecretString' --output text | sed 's:/*$::')

          echo "PUBLISH_APP_IMAGE_ID_TAG=$DOCKER_ECR/publish_app:latest" >> $GITHUB_OUTPUT

          RUBY_VERSION=$(${{ inputs.version_command }})
          echo "RUBY_VERSION=$RUBY_VERSION" >> $GITHUB_OUTPUT
          BASE_IMAGE="$DOCKER_ECR/ruby-base:${RUBY_VERSION}"
          echo "BASE_IMAGE=$BASE_IMAGE" >> $GITHUB_OUTPUT

          # Strip git ref prefix from version
          IMAGE_ID=$(echo "$DOCKER_ECR/${{ inputs.ecr_repository }}" | tr '[A-Z]' '[a-z]')

          echo "IMAGE_ID=$IMAGE_ID" >> $GITHUB_OUTPUT

          echo "PRODUCTION_IMAGE_ID_TAG=$IMAGE_ID:$IMAGE_TAG" >> $GITHUB_OUTPUT

          echo "LATEST_IMAGE_ID_TAG=$IMAGE_ID:${{ inputs.latest_image_tag }}" >> $GITHUB_OUTPUT

          GITHUB_REGISTRY_REF="ghcr.io/ausaccessfed/${{ inputs.ecr_repository }}"
          echo "GITHUB_REGISTRY_REF=$GITHUB_REGISTRY_REF" >> $GITHUB_OUTPUT

          GITHUB_CACHE_IMAGE_ID_TAG="$GITHUB_REGISTRY_REF:cache"
          echo "GITHUB_CACHE_IMAGE_ID_TAG=$GITHUB_CACHE_IMAGE_ID_TAG" >> $GITHUB_OUTPUT

          if [ "$IS_DEFAULT_BRANCH_PUSH" == "true" ]; then
            echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=$GITHUB_CACHE_IMAGE_ID_TAG" >> $GITHUB_OUTPUT
          else
            echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=$GITHUB_REGISTRY_REF:cache-$DEFAULT_BRANCH_FOR_CACHING" >> $GITHUB_OUTPUT
          fi

          GITHUB_LATEST_IMAGE_ID_TAG="$GITHUB_REGISTRY_REF:latest"
          echo "GITHUB_LATEST_IMAGE_ID_TAG=$GITHUB_LATEST_IMAGE_ID_TAG" >> $GITHUB_OUTPUT

          if [ "$IS_DEFAULT_BRANCH_PUSH" == "true" ]; then
            echo "GITHUB_BRANCH_LATEST_IMAGE_ID_TAG=$GITHUB_LATEST_IMAGE_ID_TAG" >> $GITHUB_OUTPUT
          else
            echo "GITHUB_BRANCH_LATEST_IMAGE_ID_TAG=$GITHUB_REGISTRY_REF:latest-$DEFAULT_BRANCH_FOR_CACHING" >> $GITHUB_OUTPUT
          fi

          PROJECTS="${{ inputs.ecr_repository }}"
          if [ "${{ inputs.projects }}" != "" ]; then
            PROJECTS="${{ inputs.projects }}"
          fi
          echo "PROJECTS=$PROJECTS" >> $GITHUB_OUTPUT

          IMAGE_SCANNER_EXTRAS=""
          if [ -f "${PWD}/Dockerfile" ]; then
            IMAGE_SCANNER_EXTRAS="-v ${PWD}/Dockerfile:/app/Dockerfile ${IMAGE_SCANNER_EXTRAS}"
          fi
          if [ -f "${PWD}/.dockleignore" ]; then
            IMAGE_SCANNER_EXTRAS="-v ${PWD}/.dockleignore:/app/.dockleignore ${IMAGE_SCANNER_EXTRAS}"
          fi
          if [ -f "${PWD}/.hadolint.yaml" ]; then
            IMAGE_SCANNER_EXTRAS="-v ${PWD}/.hadolint.yaml:/app/.hadolint.yaml ${IMAGE_SCANNER_EXTRAS}"
          fi
          IMAGE_SCANNER_IMAGE_ID_TAG="$DOCKER_ECR/image-scanner:latest"

          IMAGE_SCANNER_COMMON="docker run -u 0 -v /var/run/docker.sock:/var/run/docker.sock ${IMAGE_SCANNER_EXTRAS} $IMAGE_SCANNER_IMAGE_ID_TAG"
          echo "IMAGE_SCANNER_COMMON=$IMAGE_SCANNER_COMMON" >> $GITHUB_OUTPUT

  build-test:
    needs: [init]
    strategy:
      matrix:
        arch: ${{ fromJSON(inputs.platforms) }}
    # TODO: need to make runner more configurable atm asssumes we only want amd
    runs-on: ${{ (matrix.arch == 'linux/amd64' && inputs.runner) || (matrix.arch == 'linux/arm64' && 'arm64-4core') }}
    name: Build Test Image
    steps:
      - id: env
        run: |
          MATRIX_CLEANED="$(echo "${{ matrix.arch }}" | tr / _)"
          echo "GITHUB_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT
          echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/build@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ needs.init.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_PLATFORMS: ${{ matrix.arch }}
          IMAGE_BUILD_ARGS: |
            RUBY_VERSION=${{ needs.init.outputs.RUBY_VERSION }}
            BASE_IMAGE=${{ needs.init.outputs.BASE_IMAGE }}
          IMAGE_TARGET: development
          IMAGE_CACHE_TO: type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }},mode=max
          IMAGE_CACHE_FROM: |
            type=registry,ref=${{ steps.env.outputs.GITHUB_CACHE_IMAGE_ID_TAG }}
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
          IMAGE_TAGS: |
            ${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
          IMAGE_LOAD: false
          IMAGE_PUSH: true
          IMAGE_FORCE_REBUILD: inputs.event_name == 'schedule'

  build-production:
    needs: [init, build-test]
    strategy:
      matrix:
        arch: ${{ fromJSON(inputs.platforms) }}
    runs-on: ${{ (matrix.arch == 'linux/amd64' && inputs.runner) || (matrix.arch == 'linux/arm64' && 'arm64-4core') }}
    name: Build Production Image
    steps:
      - id: env
        run: |
          MATRIX_CLEANED="$(echo "${{ matrix.arch }}" | tr / _)"
          echo "GITHUB_BRANCH_LATEST_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT
          echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/build@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ needs.init.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_PLATFORMS: ${{ matrix.arch }}
          IMAGE_BUILD_ARGS: |
            RUBY_VERSION=${{ needs.init.outputs.RUBY_VERSION }}
            BASE_IMAGE=${{ needs.init.outputs.BASE_IMAGE }}
            RELEASE_VERSION=${{ needs.init.outputs.IMAGE_TAG }}
          IMAGE_TARGET: production
          IMAGE_CACHE_TO: type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }},mode=max
          IMAGE_CACHE_FROM: |
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          # TODO: once we start trying to use gchr images we need to make the line below only happen on the default build, how does multi arch come to to play then?
          # ${{  steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_TAGS: |
            ${{  steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_LOAD: false
          IMAGE_PUSH: true

  commands:
    needs: [init, build-test]
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJSON(inputs.platforms) }}
        command: ${{ fromJSON(inputs.commands) }}
    runs-on: ${{ (matrix.arch == 'linux/amd64' && inputs.runner) || (matrix.arch == 'linux/arm64' && 'arm64-4core') }}
    name: ${{ format(matrix.command, '') }} (${{ matrix.arch }})
    services:
      mysql:
        image: ${{ ( inputs.mysql_image_tag_version != '' ) && format('mysql:{0}', inputs.mysql_image_tag_version) || '' }}
        env:
          MYSQL_ROOT_PASSWORD: password
        ports:
          - '3306:3306'
    steps:
      - id: env
        run: |
          MATRIX_CLEANED="$(echo "${{ matrix.arch }}" | tr / _)"
          echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/build@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ needs.init.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_PLATFORMS: ${{ matrix.arch }}
          IMAGE_BUILD_ARGS: |
            RUBY_VERSION=${{ needs.init.outputs.RUBY_VERSION }}
            BASE_IMAGE=${{ needs.init.outputs.BASE_IMAGE }}
          IMAGE_TARGET: development
          IMAGE_CACHE_FROM: |
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
          IMAGE_TAGS: ${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
          IMAGE_LOAD: true
          IMAGE_PUSH: false

      - name: Run
        run: |
          ${{ format(matrix.command, steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG) }}

    #  TODO: need to think about how this slots in now there is multi arch multi commands async
    # - name: zip artifacts
    #   if: always() && needs.init.outputs.IS_DEFAULT_BRANCH_PUSH != 'true' && inputs.save_test_artifacts
    #   #  TODO: adjust this to support more than 1 folder at some point (getting capybara/puppeteer results for now)
    #   # TODO: for now it assumes the test run will mount /tmp/screenshots (see puppeteer for example)
    #   run: |
    #     zip -r screenshots.zip /tmp/screenshots
    # - uses: actions/upload-artifact@0b2256b8c012f0828dc542b3febcab082c67f72b # v4.3.4
    #   if: always() && needs.init.outputs.IS_DEFAULT_BRANCH_PUSH != 'true' && inputs.save_test_artifacts
    #   with:
    #     name: failed_images
    #     path: screenshots.zip
  image-lint:
    needs: [init, build-production]
    strategy:
      matrix:
        arch: ${{ fromJSON(inputs.platforms) }}
    runs-on: ${{ (matrix.arch == 'linux/amd64' && inputs.runner) || (matrix.arch == 'linux/arm64' && 'arm64-4core') }}
    env:
      DOCKLE_HOST: 'unix:///var/run/docker.sock'
    name: Running Image lint on ${{ matrix.arch }}
    steps:
      - id: env
        run: |
          MATRIX_CLEANED="$(echo "${{ matrix.arch }}" | tr / _)"
          echo "GITHUB_BRANCH_LATEST_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT
          echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/build@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ needs.init.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_PLATFORMS: ${{ matrix.arch }}
          IMAGE_BUILD_ARGS: |
            RUBY_VERSION=${{ needs.init.outputs.RUBY_VERSION }}
            BASE_IMAGE=${{ needs.init.outputs.BASE_IMAGE }}
            RELEASE_VERSION=${{ needs.init.outputs.IMAGE_TAG }}
          IMAGE_TARGET: production
          IMAGE_CACHE_TO: type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }},mode=max
          IMAGE_CACHE_FROM: |
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_TAGS: |
            ${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_LOAD: true
          IMAGE_PUSH: false

      - name: Run
        id: run
        run: |
          ${{needs.init.outputs.IMAGE_SCANNER_COMMON}} \
            ./scripts/lint \
            ${{ steps.env.outputs.GITHUB_LATEST_IMAGE_ID_TAG }} \
            /app/Dockerfile

  image-scan:
    needs: [init, build-production]
    strategy:
      matrix:
        arch: ${{ fromJSON(inputs.platforms) }}
    runs-on: ${{ (matrix.arch == 'linux/amd64' && inputs.runner) || (matrix.arch == 'linux/arm64' && 'arm64-4core') }}
    name: Running Image scan on ${{ matrix.arch }}
    steps:
      - id: env
        run: |
          MATRIX_CLEANED="$(echo "${{ matrix.arch }}" | tr / _)"
          echo "GITHUB_BRANCH_LATEST_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT
          echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/build@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ needs.init.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_PLATFORMS: ${{ matrix.arch }}
          IMAGE_BUILD_ARGS: |
            RUBY_VERSION=${{ needs.init.outputs.RUBY_VERSION }}
            BASE_IMAGE=${{ needs.init.outputs.BASE_IMAGE }}
            RELEASE_VERSION=${{ needs.init.outputs.IMAGE_TAG }}
          IMAGE_TARGET: production
          IMAGE_CACHE_TO: type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }},mode=max
          IMAGE_CACHE_FROM: |
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_TAGS: |
            ${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_LOAD: true
          IMAGE_PUSH: false

      - name: Run Image scan on production image for cves
        run: |
          ${{ needs.init.outputs.IMAGE_SCANNER_COMMON }} \
            ./scripts/scan \
            ${{ needs.init.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }} \
            $IMAGE_SHA \
            /app/Dockerfile \
            ${{ secrets.SNYK_TOKEN }} \
            true

  push-to-ecr:
    needs: [init, commands, image-scan, image-lint, build-production]
    if: needs.init.outputs.SHOULD_PUSH_IMAGE_TO_ECR == 'true'
    strategy:
      matrix:
        arch: ${{ fromJSON(inputs.platforms) }}
    runs-on: ${{ (matrix.arch == 'linux/amd64' && inputs.runner) || (matrix.arch == 'linux/arm64' && 'arm64-4core') }}
    name: Pushing images to ecr
    steps:
      - id: env
        run: |
          MATRIX_CLEANED="$(echo "${{ matrix.arch }}" | tr / _)"
          echo "MATRIX_CLEANED=$MATRIX_CLEANED" >> $GITHUB_OUTPUT
          echo "GITHUB_BRANCH_LATEST_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT
          echo "GITHUB_BRANCH_CACHE_IMAGE_ID_TAG=${{ needs.init.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}-$MATRIX_CLEANED" >> $GITHUB_OUTPUT

      - uses: ausaccessfed/workflows/.github/actions/build@feature/moving-ro-more-async
        with:
          BRANCH_NAME: ${{ needs.init.outputs.BRANCH_NAME }}
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_PLATFORMS: ${{ matrix.arch }}
          IMAGE_BUILD_ARGS: |
            RUBY_VERSION=${{ needs.init.outputs.RUBY_VERSION }}
            BASE_IMAGE=${{ needs.init.outputs.BASE_IMAGE }}
            RELEASE_VERSION=${{ needs.init.outputs.IMAGE_TAG }}
          IMAGE_TARGET: production
          IMAGE_CACHE_FROM: |
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_CACHE_IMAGE_ID_TAG }}
            type=registry,ref=${{ steps.env.outputs.GITHUB_BRANCH_LATEST_IMAGE_ID_TAG }}
          IMAGE_TAGS: |
            ${{ needs.init.outputs.PRODUCTION_IMAGE_ID_TAG }}
            ${{ needs.init.outputs.LATEST_IMAGE_ID_TAG }}
            ${{ needs.init.outputs.PRODUCTION_IMAGE_ID_TAG }}-${{ steps.env.outputs.MATRIX_CLEANED }}
          IMAGE_LOAD: false
          IMAGE_PUSH: true

  # TODO: is there a way to get the logic below as part of the above?
  # https://github.com/docker/build-push-action/issues/906
  update-ecr-manifests:
    needs: [push-to-ecr, init]
    name: 'Update ecr manifests'
    runs-on: ubuntu-latest
    if: needs.init.outputs.SHOULD_PUSH_IMAGE_TO_ECR == 'true'
    steps:
      - uses: ausaccessfed/workflows/.github/actions/init@feature/moving-ro-more-async
        with:
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}

      - name: Create and Push Docker Manifest
        run: |
          PLATFORMS_STRING=$(echo "${{ inputs.platforms }}" | tr -d "[]'" | tr / _ | awk -v ORS=' ' 'BEGIN{RS=","}{print "${{ needs.init.outputs.PRODUCTION_IMAGE_ID_TAG }}-"$0}')
          docker buildx imagetools create --tag ${{ needs.init.outputs.PRODUCTION_IMAGE_ID_TAG }} $PLATFORMS_STRING ${{ needs.init.outputs.LATEST_IMAGE_ID_TAG }}

          # dont update latest tag if /deploy
          if [ "${{ needs.init.outputs.IS_SLASH_DEPLOY }}" != "true" ]; then
            docker buildx imagetools create --tag ${{ needs.init.outputs.LATEST_IMAGE_ID_TAG }} $PLATFORMS_STRING ${{ needs.init.outputs.PRODUCTION_IMAGE_ID_TAG }}
          fi

  update-terraform-manifests:
    needs: [push-to-ecr, init]
    name: 'Update terraform manifests'
    runs-on: ubuntu-latest
    if: needs.init.outputs.SHOULD_PUSH_IMAGE_TO_ECR == 'true'
    steps:
      - uses: ausaccessfed/workflows/.github/actions/init@feature/moving-ro-more-async
        with:
          ROLE: ${{ secrets.ROLE }}
          ECR_REPOSITORY: ${{ inputs.ecr_repository }}

      ## no point making the gitops repo triggers async, they will fight each other
      ## and usually only 1 if statement is called anyway
      - name: Update GitOps Repo to trigger deploys
        if: inputs.production_environments != '' && (needs.init.outputs.IS_DEFAULT_BRANCH_PUSH == 'true' || needs.init.outputs.IS_MONTHLY_BUILD == 'true')
        run: |
          printenv > .envs
          docker run --env-file .envs \
          -e PROJECTS="${{ needs.init.outputs.PROJECTS }}" \
          -e IMAGE_TAG=${{ needs.init.outputs.IMAGE_TAG }} \
          -e ENVIRONMENTS="${{ inputs.production_environments }}" \
          -e ECR_REPOSITORY="${{ inputs.ecr_repository }}" \
          ${{ needs.init.outputs.PUBLISH_APP_IMAGE_ID_TAG }}

      - name: Update GitOps Repo to trigger deploys for test
        if: inputs.test_environments != '' && needs.init.outputs.IS_DEFAULT_DEVELOPMENT_BRANCH_PUSH == 'true'
        run: |
          printenv > .envs
          docker run --env-file .envs \
          -e PROJECTS="${{ needs.init.outputs.PROJECTS }}" \
          -e IMAGE_TAG=${{ needs.init.outputs.IMAGE_TAG }} \
          -e ENVIRONMENTS="${{ inputs.test_environments }}" \
          -e ECR_REPOSITORY="${{ inputs.ecr_repository }}" \
          ${{ needs.init.outputs.PUBLISH_APP_IMAGE_ID_TAG }}

      - name: Update GitOps Repo to trigger deploys for development
        if: inputs.development_environments != '' && needs.init.outputs.IS_SLASH_DEPLOY == 'true'
        run: |
          printenv > .envs
          docker run --env-file .envs \
          -e PROJECTS="${{ needs.init.outputs.PROJECTS }}" \
          -e IMAGE_TAG=${{ needs.init.outputs.IMAGE_TAG }} \
          -e ENVIRONMENTS="${{ inputs.development_environments }}" \
          -e ECR_REPOSITORY="${{ inputs.ecr_repository }}" \
          ${{ needs.init.outputs.PUBLISH_APP_IMAGE_ID_TAG }}

  update-comments:
    needs:
      [
        init,
        build-test,
        build-production,
        commands,
        image-lint,
        image-scan,
        push-to-ecr,
        update-ecr-manifests,
        update-terraform-manifests
      ]
    name: 'update-comments'
    runs-on: ubuntu-latest
    if: needs.init.outputs.IS_SLASH_DEPLOY == 'true' && always()
    steps:
      - name: check for failures
        id: failure-check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=
          STATUS="failure"
          URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ "${{ needs.build-test.result }}" == "failure" ]; then
            OUTPUT="${OUTPUT}Building the Test image has failed! "
          fi

          if [ "${{ needs.build-production.result }}" == "failure" ]; then
            OUTPUT="${OUTPUT}Building the Production image has failed!"
          fi

          if [ "${{ needs.commands.result }}" == "failure" ]; then
            OUTPUT="${OUTPUT}Some of the commands have failed!"
          fi

          if [ "$OUTPUT" == "" ]; then
            OUTPUT="Manifest updated, Deploying to ${{ inputs.dev_url }} (may take up to 5 minutes)"
            STATUS="success"
            URL="${{ inputs.dev_url }}"
          fi
          echo "ADHOC_OUTPUT=$OUTPUT" >> $GITHUB_OUTPUT
          echo "ADHOC_STATUS=$STATUS" >> $GITHUB_OUTPUT
          echo "ADHOC_URL=$URL" >> $GITHUB_OUTPUT
          if [ "${{ inputs.event_comment_id }}" != "" ]; then
            gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/ausaccessfed/${{ inputs.ecr_repository }}/issues/comments/${{ inputs.event_comment_id }}
          fi

      - name: Set final commit status
        uses: myrotvorets/set-commit-status-action@3730c0a348a2ace3c110851bed53331bc6406e9f # v2.0.1
        with:
          sha: ${{ needs.init.outputs.HEAD_SHA }}
          token: ${{ secrets.GITHUB_TOKEN }}
          status: ${{ steps.failure-check.outputs.ADHOC_STATUS }}
          targetUrl: ${{ steps.failure-check.outputs.ADHOC_URL }}
          description: ${{ steps.failure-check.outputs.ADHOC_OUTPUT }}
          context: 'Dev federation deploy'

  finish:
    needs:
      [
        init,
        build-test,
        build-production,
        commands,
        image-lint,
        image-scan,
        push-to-ecr,
        update-ecr-manifests,
        update-terraform-manifests
      ]
    name: 'finish'
    runs-on: ubuntu-latest
    steps:
      - name: check for failures
        run: |
          echo "finished"
