name: 'Summarise'
description: ''
inputs:
  OUTPUT_FILES:
    description: 'combines into a single output file'
    default: ''
  OUTPUT_MESSAGE:
    description: 'Will be used to generate the OUTPUT_FILE, note will override OUTPUT_FILE if provided'
    default: ''
  SLACK_WEBHOOK_URL:
    description: 'If not null, will post to slack'
    default: ''
  ENABLE_PR:
    description: 'If true, will post pr as comment (STILL TODO)'
    default: 'false'
  CREATE_COMMENT:
    description: 'If true, will create a new comment, if false will delete existing comment'
    default: 'true'
  PR_NUMBER:
    description: 'PR number to post comment to'
    default: ''
  ENABLE_ACTION_SUMMARY:
    description: 'If true, will post to summary tab in flow'
    default: 'true'
  TITLE:
    description: 'Summary Title'
  SUCCESS:
    description: 'If the task was successful'
outputs:
  GITHUB_OUTPUT_FILE:
    description: 'output file'
    value: ${{ steps.create_output.outputs.OUTPUT_FILE }}
runs:
  using: 'composite'
  steps:
    - id: create_output
      shell: bash
      run: |
        OUTPUT_FILE="/tmp/$(uuidgen).txt"
        echo "OUTPUT_FILE=$OUTPUT_FILE" >> $GITHUB_OUTPUT
        echo "${{ inputs.OUTPUT_MESSAGE }}\n" > $OUTPUT_FILE
        IFS=',' read -r -a files <<< "$OUTPUT_FILES"
        for file in "${files[@]}"; do
          if [ -e "$file" ]; then
            echo "$file\n" >> "$OUTPUT_FILE"
            cat "$file\n" >> "$OUTPUT_FILE"
            echo "Appended $file to $OUTPUT_FILE"
          else
            echo "$file does not exist."
          fi
        done

        CLEANED_MESSAGE=$(echo "${{ inputs.OUTPUT_MESSAGE }}" | tr -d '[:space:]')
        # Finish early if CLEANED_MESSAGE is empty
        if [ -z "$CLEANED_MESSAGE" ]; then
          echo "Empty output"
          HAS_OUTPUT=true
        else
          echo "Output file created."
          HAS_OUTPUT=false
        fi
        echo "HAS_OUTPUT=$HAS_OUTPUT" >> $GITHUB_OUTPUT

    - id: split_file
      if: steps.create_output.outputs.HAS_OUTPUT == "true"
      shell: bash
      run: |
        echo "TITLE=$(echo "${{ inputs.TITLE }}" | tr '()' '  ' | tr '"' "'")" >> $GITHUB_OUTPUT
        FILE_SIZE=$(stat -c%s "${{ steps.create_output.outputs.OUTPUT_FILE }}")
        CHUNK_SIZE=$((900 * 1024)) # 700KB in bytes

        if [ $FILE_SIZE -gt $CHUNK_SIZE ]; then
          split -b $CHUNK_SIZE "${{ steps.create_output.outputs.OUTPUT_FILE }}" chunk_
          echo "File split into chunks."
        else
          cp "${{ steps.create_output.outputs.OUTPUT_FILE }}" chunk_aa
          echo "File is small enough, no need to split."
        fi

    - if: inputs.ENABLE_PR == 'true' && steps.create_output.outputs.HAS_OUTPUT == "true"
      id: update-pull-request
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
      with:
        github-token: ${{ github.token }}
        script: |
          const fs = require("fs");

          const create_comment = "true" == "${{ inputs.CREATE_COMMENT }}"
          let output = fs.readFileSync("${{ steps.create_output.outputs.OUTPUT_FILE }}", "utf8");
          const task_failed =  "false" == "${{ inputs.SUCCESS }}"
          const title = "${{ inputs.title }}"
          const issue_number = "${{ inputs.pr_number }}"

          // Retrieve existing bot comments for the PR
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number,
          })
          const botComment = comments.find(comment => {
            return comment.user.type === 'Bot' && comment.body.includes(title)
          })

          const MAX_GITHUB_COMMENT_LENGTH = 65536 - 100;
          output = output.slice(0, MAX_GITHUB_COMMENT_LENGTH)
          if (output.length == MAX_GITHUB_COMMENT_LENGTH) {
            output += "...\nPlease review the output in github actions logs because it's too long"
          }

          let output_title = "Show Output"
          if (task_failed == "true") {
            output_title = "Show Failed Output"
          }

          const body = `## ${title}
          <details><summary>${output_title}</summary>

          \`\`\`\n
          ${output}
          \`\`\`

          </details>`

          if (botComment) {
            if (create_comment) {
              github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              })
            } else {
             github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
              })
            }
          } else if (create_comment){
            github.rest.issues.createComment({
              issue_number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            })
          }

    - id: slack_message
      shell: bash
      if: inputs.SLACK_WEBHOOK_URL != '' && steps.create_output.outputs.HAS_OUTPUT == "true"
      run: |
        wget -O /tmp/slack_webhook.sh https://raw.githubusercontent.com/ausaccessfed/workflows/main/scripts/slack_webhook.sh
        chmod +x /tmp/slack_webhook.sh
        /tmp/slack_webhook.sh "${{ steps.split_file.outputs.TITLE }}" "${{ inputs.SLACK_WEBHOOK_URL }}" "${{github.repository}}" "${{github.run_id}}" "false"

    - id: summary_tab_1
      if: inputs.ENABLE_ACTION_SUMMARY == 'true' && steps.create_output.outputs.HAS_OUTPUT == "true"
      shell: bash
      run: |
        if [ -s "chunk_aa" ]; then
          echo '<details>' >> $GITHUB_STEP_SUMMARY
          echo "<summary>${{ steps.split_file.outputs.TITLE }} (part 1)</summary>" >> $GITHUB_STEP_SUMMARY
          echo '  ' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$(cat chunk_aa)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '</details>' >> $GITHUB_STEP_SUMMARY
        else
          echo "Output file is empty, skipping summary."
        fi
    - id: summary_tab_2
      if: inputs.ENABLE_ACTION_SUMMARY == 'true' && steps.create_output.outputs.HAS_OUTPUT == "true"
      shell: bash
      run: |
        if [ -s "chunk_ab" ]; then
          echo '<details>' >> $GITHUB_STEP_SUMMARY
          echo "<summary>${{ steps.split_file.outputs.TITLE }} (part 1)</summary>" >> $GITHUB_STEP_SUMMARY
          echo '  ' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$(cat chunk_ab)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '</details>' >> $GITHUB_STEP_SUMMARY
        fi
    - id: summary_tab_3
      if: inputs.ENABLE_ACTION_SUMMARY == 'true' && steps.create_output.outputs.HAS_OUTPUT == "true"
      shell: bash
      run: |
        if [ -s "chunk_ac" ]; then
          echo '<details>' >> $GITHUB_STEP_SUMMARY
          echo "<summary>${{ steps.split_file.outputs.TITLE }} (part 1)</summary>" >> $GITHUB_STEP_SUMMARY
          echo '  ' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$(cat chunk_ac)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '</details>' >> $GITHUB_STEP_SUMMARY
        fi
    - id: verify_size
      if: steps.create_output.outputs.HAS_OUTPUT == "true"
      shell: bash
      run: |
        if [ -s "chunk_ad" ]; then
          echo "We shouldn't be getting outputs this big!"
          exit 1
        fi
    - id: throw_error
      shell: bash
      if: inputs.SUCCESS == 'failure' || inputs.SUCCESS == 'false'
      run: |
        cat "${{ steps.create_output.outputs.OUTPUT_FILE }}"
        exit 1
